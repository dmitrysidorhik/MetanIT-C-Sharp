using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _4_Операции_языка_Си_шарп
{
    class Program
    {
        static void Main(string[] args)
        {
            int x1 = 3;
            int x2 = ++x1; //префиксный инкремент
            Console.WriteLine(x2); //4
            int y1 = 3;
            int y2 = y1++; //постфиксный инкремент
            Console.WriteLine(y2); //3
            

            /////////Логические операции над числами
            Console.WriteLine("Логические операции над числами");
            //Логические операции над числами производятся поразрядно


            // & (логическое умножение "Поразрядное И")
            int m1 = 2;
            int l1 = 5;
            //(0*1, 1*0, 0*1) и в итоге получим 000
            Console.WriteLine(m1 & l1); // 0 
            int m2 = 4;
            int l2 = 5;
            //Во втором случае у нас вместо двойки число 4, у которого в первом разряде 1, 
            //так же как и у числа 5, поэтому в итоге получим (1*1, 0*0, 0 *1) = 100, то есть число 4 в десятичном формате.
            Console.WriteLine(m2 & l2);//4
            //(11010011)
            //(10011001)
            //(10010001)


            // | (логическое сложение "Поразрядное ИЛИ")
            int m3 = 2; // 010
            int l3 = 5; // 101
            // (1+0, 0+1, 1+0) -> 111 -> 7    (1+1 -> 1)
            Console.WriteLine(m3 | l3);  // 7
            int m4 = 5; //0101
            int l4 = 8; //1000
            // (0+1, 1+0, 0+0, 1+0) -> 1101 -> 13
            Console.WriteLine(m4 | l4); // 13
            //(11010011)
            //(10011001)
            //(11011011)


            // ^ (логическое исключающее ИЛИ "Порязрядное исключающее ИЛИ")
            // Также эту операцию называют XOR, нередко ее применяют для простого шифрования:
            int m5 = 45; // Значение, которое надо зашифровать - в двоичной форме 101101
            int key = 102; //Пусть это будет ключ - в двоичной форме 1100110
            int encrypt = m5 ^ key; //Результатом будет число 1001011 или 75
            Console.WriteLine("Зашифрованное число: " + encrypt);
            int decrypt = encrypt ^ key; // Результатом будет исходное число 45
            Console.WriteLine("Расшифрованное число: " + decrypt);
            // Здесь опять же производятся поразрядные операции. Если у нас значения текущего 
            // разряда у обоих чисел разные, то возвращается 1, иначе возвращается 0.
            //(0101101) -> 45
            //(1100110) -> 102
            //(1001011) -> 75


            // ~ (логическое отрицание "Дополнение до 1 (унарный оператор НЕ)")
            int m6 = 5; //101
            Console.WriteLine(~m6);
            // Еще одна поразрядная операция, которая инвертирует все 
            // разряды: если значение разряда равно 1, то оно становится равным нулю, и наоборот.
            //(11010011)
            //(00101100)



            Console.WriteLine("Операции сдвига");
            // x<<y - сдвигает число x влево на y разрядов. Например, 4<<1 сдвигает 
            // число 4 (которое в двоичном представлении 100) на один разряд влево, 
            // то есть в итоге получается 1000 или число 8 в десятичном представлении.

            // x>>y - сдвигает число x вправо на y разрядов. Например, 16>>1 сдвигает 
            // число 16 (которое в двоичном представлении 10000) на один разряд вправо, 
            // то есть в итоге получается 1000 или число 8 в десятичном представлении.
            int m8 = 3; //011
            int m9 = 1;
            Console.WriteLine(m8>>m9); //001
            int m10 = 16; //10000
            int m11 = 1;  
            Console.WriteLine(m10 >> m11); //01000       -> 8      
            Console.WriteLine(m10 << m11); //100000      -> 32
            //(100)
            //(1000)  <<
            //(10)    >>
            Console.ReadKey();


        }
    }
}
